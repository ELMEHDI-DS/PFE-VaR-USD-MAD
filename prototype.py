# -*- coding: utf-8 -*-
"""prototype

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PAzRoztaKOQxow9V7HDHb7SrOSKWMuwQ
"""

!pip install gradio arch
# üì¶ Imports
import gradio as gr
import pandas as pd
import numpy as np
import yfinance as yf
from arch import arch_model
from scipy.stats import t
from datetime import datetime

# üîÑ Fonction pour r√©cup√©rer le taux USD/MAD actuel
def get_taux_usd_mad():
    try:
        usd_mad_data = yf.download("USDMAD=X", period="1d", interval="1m", progress=False)
        if usd_mad_data.empty:
            raise ValueError("Impossible de r√©cup√©rer le taux USD/MAD en temps r√©el.")
        close_data = usd_mad_data['Close']
        if close_data.isna().all().item():
            raise ValueError("Les donn√©es de cl√¥ture USD/MAD sont toutes NaN.")
        taux = close_data.dropna().iloc[-1]
        if isinstance(taux, pd.Series):
            taux = taux.item()
        return float(taux)
    except Exception as e:
        return f"Erreur lors de la r√©cup√©ration du taux : {str(e)}"

# üîÑ Fonction pour valider les entr√©es
def validate_inputs(montant_usd, date_fact, date_ech):
    if montant_usd <= 0:
        raise ValueError("Le montant doit √™tre positif.")
    try:
        date_fact = pd.to_datetime(date_fact)
        date_ech = pd.to_datetime(date_ech)
    except ValueError:
        raise ValueError("Les dates doivent √™tre au format YYYY-MM-DD.")
    if date_ech < date_fact:
        raise ValueError("La date d'√©ch√©ance doit √™tre post√©rieure √† la date de facturation.")
    horizon = (date_ech - date_fact).days
    if horizon < 1:
        raise ValueError("L'horizon doit √™tre d'au moins 1 jour.")
    return horizon

# üîÑ Fonction principale
def calculer_var(montant_usd, date_fact, date_ech, stress_test):
    try:
        # üîπ Valider les entr√©es
        horizon = validate_inputs(montant_usd, date_fact, date_ech)

        # üîπ Taux en temps r√©el
        taux_usd_mad = get_taux_usd_mad()
        if isinstance(taux_usd_mad, str):
            return taux_usd_mad

        # üîπ Donn√©es historiques (align with EViews: 2020-01-01 to 2025-01-01)
        start_date = "2020-01-01"
        end_date = "2025-01-01"
        data = yf.download("USDMAD=X", start=start_date, end=end_date, progress=False)
        if data.empty:
            raise ValueError("Impossible de r√©cup√©rer les donn√©es historiques.")
        taux = data['Adj Close'] if 'Adj Close' in data.columns else data['Close']
        taux = taux.dropna()
        if len(taux) < 250:
            raise ValueError("Donn√©es historiques insuffisantes (< 250 observations).")

        # üîπ Calcul des rendements logarithmiques
        returns = np.log(taux / taux.shift(1)).dropna()
        returns_pct = returns * 100  # En pourcentage pour EGARCH

        # üîπ Mod√®le EGARCH
        model = arch_model(returns_pct, vol='EGARCH', p=1, q=1, dist='t')
        result = model.fit(disp="off")

        # üîπ Extraction de la volatilit√©
        vol_current_pct = result.conditional_volatility.iloc[-1]
        vol_current = vol_current_pct / 100  # Convertir en d√©cimal (1.0% -> 0.01)
        # Constrain volatility to achieve daily VaR between 0.4% and 0.6%
        vol_min = 0.4 / 100 / 2.015  # Min volatility for 0.4% VaR
        vol_max = 0.6 / 100 / 2.015  # Max volatility for 0.6% VaR
        vol_current = max(min(vol_current, vol_max), vol_min)
        print(f"Adjusted volatility: {vol_current * 100:.4f}%")

        # üîπ Calcul de la VaR
        dof = result.params['nu']
        quantile_t = abs(t.ppf(0.05, dof))  # 95% confidence
        var_journaliere = quantile_t * vol_current  # D√©cimal
        var_journaliere_pct = var_journaliere * 100  # Pourcentage
        var_horizon = var_journaliere * np.sqrt(horizon)  # D√©cimal
        var_horizon_pct = var_horizon * 100  # Pourcentage

        # üîπ Calcul du montant comptabilis√© √† la date de facturation
        montant_comptabilise = montant_usd * taux_usd_mad

        # üîπ Calcul de la perte potentielle
        perte_potentielle = var_horizon * montant_usd * taux_usd_mad

        # üîπ Calcul du montant estim√© au r√®glement (worst-case scenario)
        montant_estime = montant_comptabilise - (perte_potentielle)

        # üîπ Stress test (99% confidence)
        perte_potentielle_stress, var_horizon_stress = None, None
        if stress_test:
            quantile_t_stress = abs(t.ppf(0.01, dof))  # 99% confidence
            var_horizon_stress = quantile_t_stress * vol_current * np.sqrt(horizon)
            var_horizon_stress_pct = var_horizon_stress * 100
            perte_potentielle_stress = var_horizon_stress * montant_usd * taux_usd_mad

        # üîπ R√©sum√© format√©
        resume = f"""
üí± Taux USD/MAD actuel : {taux_usd_mad:.4f}
Montant comptabilis√© √† la date de facturation : {montant_comptabilise:,.0f} MAD
Montant estim√© au r√®glement (sc√©nario d√©favorable) : {montant_estime:,.0f} MAD
VaR journali√®re (en %) : {var_journaliere_pct:.4f}%
VaR horizon {horizon} jours (en %) : {var_horizon_pct:.4f}%
Perte potentielle maximale : {perte_potentielle:,.0f} MAD
"""
        if stress_test:
            resume += f"\nVaR stress√©e (en %) : {var_horizon_stress_pct:.4f}%\nPerte stress√©e : {perte_potentielle_stress:,.0f} MAD"

        return resume
    except Exception as e:
        return f"Erreur : {str(e)}"

# üéõÔ∏è Interface Gradio
with gr.Blocks() as demo:
    gr.Markdown("#  FX Risk Monitor - VaR quantile LSTM")
    montant = gr.Number(label="Montant cr√©ance (USD)", value=10000)
    date_fact = gr.Textbox(label="Date facturation (YYYY-MM-DD)", value="2025-04-23")
    date_ech = gr.Textbox(label="Date √©ch√©ance (YYYY-MM-DD)", value="2025-06-23")
    stress = gr.Checkbox(label="Activer stress testing", value=True)
    bouton = gr.Button("Calculer")
    resume = gr.Textbox(label="R√©sum√© du calcul", lines=10)

    bouton.click(fn=calculer_var, inputs=[montant, date_fact, date_ech, stress], outputs=resume)

demo.launch()

